
1.阻塞式IO-Reactor高性能模式

2.java的线程join和线程池，java Future和Guava ListenableFuture的两种常见异步回调技术

3.Netty

4.zookeeper

5.redis



Netty是JBOSS提供的一个Java开源框架，是基于NIO的客户端/服务器编程框架，它既能 快速开发高并发、高可用、高可靠性的网络服务器程序，也能开发高可用、高可靠的客户端 程序。Netty提供异步的、事件驱动的网络应用程序框架和工具。Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户 可以方便地主动获取或者通过通知机制获得IO操作结果。

Netty之所以这么火，与它的巨大优点是密不可分的，大致可以总结如下：
 API使用简单，开发门槛低。
 功能强大，预置了多种编解码功能，支持多种主流协议。
 定制能力强，可以通过ChannelHandler对通信框架进行灵活扩展。
 性能高，与其他业界主流的NIO框架对比，Netty的综合性能最优。
 成熟、稳定，Netty修复了已经发现的所有JDK NIO中的BUG，业务开发人员不需
要再为NIO的BUG而烦恼。
 社区活跃，版本迭代周期短，发现的BUG可以被及时修复。


Kafka、RocketMQ、火热的ElasticSearch开源搜索引擎、大数据处理 Hadoop的RPC框架Avro、分布式通信框架Dubbo。



Redis是Remote Dictionary Server（远程字典服务器）的缩写，最初是作为数据库的工具 来使用的。是目前使用广泛、高效的一款开源缓存。Redis使用C语言开发，将数据保存在内存中，可以看成是一款纯内存的数据库，所以它的数据存取速度非常快。

Redis通过键-值对（Key-Value Pair）的形式来存储数据，类似于Java中的Map映射。Redis的Key键，只能是string字符串类型。Redis的Value值类型包括：string字符类型、map映射类 型、list列表类型、set集合类型、sortedset有序集合类型。
Redis的主要应用场景：缓存（数据查询、短连接、新闻内容、商品内容等）、分布式会话（Session）、聊天室的在线好友列表、任务队列（秒杀、抢购、12306等）、应用排行榜、访问统计、数据过期处理（可以精确到毫秒）。



相对于其他的键-值对（Key-Value）内存数据库（如Memcached）而言，Redis具有如下

*****特点*****：

1.**速度快** ：不需要等待磁盘的IO，在内存之间进行的数据存储和查询，速度非常快。 当然，缓存的数据总量不能太大，因为受到物理内存空间大小的限制。

2.**丰富的数据结** ：除了string之外，还有list、hash、set、sortedset，一共五种类型。

3.**单线程** ：避免了线程切换和锁机制的性能消耗。

4.**可持久化** ： 支持RDB与AOF两种方式，将内存中的数据写入外部的物理存储设备。

5.**支持发布/订阅**。

6.**支持Lua脚本**。

7.**支持分布式锁** ： 在分布式系统中，如果不同的节点需要访同到一个资源，往往需 要通过互斥机制来防止彼此干扰，并且保证数据的一致性。在这种情况下，需要使用到分布式锁。分布式锁和Java的锁用于实现不同线程之间的同步访问，原理上是类似的。

8.**支持原子操作和事务** ： Redis事务是一组命令的集合。一个事务中的命令要么都执行，要么都不执行。如果命令在运行期间出现错误，不会自动回滚。

9.**支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群（3.0 版本以上）**

10.**支持管道**  Redis管道是指客户端可以将多个命令一次性发送到服务器，然后由服务器一次性返回所有结果。管道技术的优点是：在批量执行命令的应用场景中，可以大大减少网络传输的开销，提高性能。


### 分布式利器ZooKeeper
单体应用在达到了性能瓶颈之后，就必须靠分布式集群解决高并发问题，而集群的分布 式架构和集群节点之间的交互协调，一定少不了可靠的分布式协调工ZooKeeper就是目前极为重要的分布式协调工具。

ZooKeeper的核心优势是，实现了分布式环境的数据一致性，简单地说：每时每刻我们访问ZooKeeper的树结构时，不同的节点返回的数据都是一致的。也就是说，对ZooKeeper 进行数据访问时，无论是什么时间，都不会引起脏读、幻读、不可重复读问题。

“**脏读**”是指一个事务中访问到了另外一个事务未提交的数据。

“**不可重复读**”是指在一个事务内根据同一个条件对数据进行多次查询，但是结果却 不一致，产生的原因是其他事务对该数据就行了修改。

“**幻读**”是指在当两个完全相同的查询执行时，第二次查询所返回的结果集和第一个查询所返回的结果集不相同，发生的原因也 是另外一个事务新增、删除了第一个事务结果集里面的数据。

**“不可重复读”和“幻读”的区别**是：“不可重复读”关注的重点在于记录的**更新操作**，同样的记录再次读取出来后发现返回的数据值不一样了；“幻读”关注的重点在于记录**新增**或者**删除**操作 (数据条数发生了变化)，同样的条件第 1 次和第 2 次查询出来的记录数不一样。

